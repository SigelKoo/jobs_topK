Python使用timsort作为排序算法

C++使用introsort作为排序算法

Rust使用pdqsort作为排序算法

Go（<=1.18）使用introsort作为排序算法



插入排序

将元素不断插入已经排好序的array中

- 将起始元素放入array中，其本身是个有序array
- 后续元素插入有序array中，不断交换，直到找到第一个比其小的元素

| Best | Avg            | Worst  |
| ---- | -------------- | ------ |
| O(n) | O(n^2)         | O(n^2) |
| 有序 | 翻转的对数决定 | 逆序   |

快速排序

分治思想，不断分割序列直到序列整体有序

- 选定一个pivot
- 使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列

| Best                        | Avg       | Worst                                                        |
| --------------------------- | --------- | ------------------------------------------------------------ |
| O(n*logn)                   | O(n*logn) | O(n^2)                                                       |
| 每次选择的pivot恰好是中位数 |           | 每次只将一个元素放到最终位置，选择的pivot都是已知序列最小元素 |

堆排序

利用堆的性质形成的排序算法

- 构造一个大顶堆
- 将根节点（最大元素）交换到最后一个位置，调整整个堆，如此反复

| Best      | Avg       | Worst     |
| --------- | --------- | --------- |
| O(n*logn) | O(n*logn) | O(n*logn) |

根据实际场景benchmark

序列元素划分为：

- 完全随机的情况
- 有序/逆序的情况
- 元素重复度较高的情况
- 序列长度的划分（16短/128中/1024长）

完全随机情况下

- 插入排序短序列速度最快
- 快速排序中长序列速度最快
- 堆排序与最快算法差距不大

有序情况下

- 插入排序有序情况下速度最快
- 快速排序有序情况下速度最慢



pdqsort（pattern-defeating-quicksort）不稳定的混合排序算法

version 1



